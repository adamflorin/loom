// Generated by CoffeeScript 1.6.2
autowatch = 1;
var AREA, GaussianCurve, anything, onclick, ondrag, paint,
  __slice = [].slice;

AREA = {
  width: 90,
  height: 50
};

mgraphics.init();

mgraphics.relative_coords = 0;

mgraphics.autofill = 0;

mgraphics.set_line_cap("butt");

mgraphics.set_line_join("miter");

onclick = ondrag = function(x, y) {
  var deviation, mean;

  mean = Math.min(Math.max(x, 0), AREA.width) / AREA.width;
  deviation = 1 - Math.min(Math.max(y, 0), AREA.height) / AREA.height;
  GaussianCurve.prototype.set("mean", mean);
  GaussianCurve.prototype.set("deviation", deviation);
  outlet(0, ["mean", mean]);
  return outlet(0, ["deviation", deviation]);
};

anything = function() {
  var _ref;

  return (_ref = GaussianCurve.prototype).set.apply(_ref, [messagename].concat(__slice.call(arrayfromargs(arguments))));
};

paint = function() {
  return GaussianCurve.prototype.draw();
};

GaussianCurve = (function() {
  function GaussianCurve() {}

  GaussianCurve.prototype.CORNER_RADIUS = 8;

  GaussianCurve.prototype.DEVIATION_PIXEL_COEFFICIENT = 32;

  GaussianCurve.prototype.ANIMATION_FRAMES = 2;

  GaussianCurve.prototype.ANIMATION_FRAME_DURATION_MS = 25;

  GaussianCurve.prototype.set = function() {
    var key, value;

    key = arguments[0], value = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    this[key] = value;
    if (key === "activatePosition") {
      return this.startLineAnimation();
    } else {
      return mgraphics.redraw();
    }
  };

  GaussianCurve.prototype.draw = function() {
    if ((this.contrast_frame != null) && (this.surface_bg != null)) {
      this.drawBackground();
    }
    if ((this.mean != null) && (this.deviation != null) && (this.selection != null)) {
      this.drawCurve();
    }
    if ((this.linePosition != null) && (this.selection != null)) {
      return this.drawPosition();
    }
  };

  GaussianCurve.prototype.drawBackground = function() {
    var x, y, _i, _len, _ref, _results;

    mgraphics.set_source_rgba.apply(mgraphics, this.contrast_frame);
    mgraphics.rectangle(0, 0, AREA.width, AREA.height);
    mgraphics.fill_with_alpha(1.0);
    _ref = [0, AREA.width];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      x = _ref[_i];
      _results.push((function() {
        var _j, _len1, _ref1, _results1;

        _ref1 = [0, AREA.height];
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          y = _ref1[_j];
          _results1.push(this.drawCorner({
            x: x,
            y: y
          }));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  GaussianCurve.prototype.drawCorner = function(corner) {
    mgraphics.new_path();
    mgraphics.move_to(corner.x, corner.y);
    mgraphics.line_to((corner.x > 0 ? corner.x - this.CORNER_RADIUS : this.CORNER_RADIUS), corner.y);
    mgraphics.curve_to(corner.x, corner.y, corner.x, corner.y, corner.x, (corner.y > 0 ? corner.y - this.CORNER_RADIUS : this.CORNER_RADIUS));
    mgraphics.line_to(corner.x, corner.y);
    mgraphics.close_path();
    mgraphics.set_source_rgba.apply(mgraphics, this.surface_bg);
    mgraphics.fill_with_alpha(1.0);
    return mgraphics.restore();
  };

  GaussianCurve.prototype.drawCurve = function() {
    var margin, midpoint, top;

    midpoint = this.mean * AREA.width;
    margin = this.deviation * this.DEVIATION_PIXEL_COEFFICIENT;
    top = 2;
    mgraphics.new_path();
    mgraphics.move_to(midpoint - AREA.width, AREA.height);
    mgraphics.curve_to(midpoint - margin, AREA.height, midpoint - margin, top, midpoint, top);
    mgraphics.curve_to(midpoint + margin, top, midpoint + margin, AREA.height, midpoint + AREA.width, AREA.height);
    mgraphics.set_line_width(2);
    mgraphics.set_source_rgba.apply(mgraphics, this.selection);
    mgraphics.stroke_with_alpha(1.0);
    return mgraphics.restore();
  };

  GaussianCurve.prototype.drawPosition = function() {
    var pixelposition;

    pixelposition = this.linePosition * AREA.width * 0.96 + 2;
    mgraphics.new_path();
    mgraphics.move_to(pixelposition, 0);
    mgraphics.line_to(pixelposition, AREA.height);
    mgraphics.set_line_width(0.5);
    mgraphics.set_source_rgba.apply(mgraphics, this.selection);
    mgraphics.stroke_with_alpha(1.0);
    return mgraphics.restore();
  };

  GaussianCurve.prototype.startLineAnimation = function() {
    var _ref, _ref1,
      _this = this;

    this.animationFrame = 0;
    if ((_ref = this.linePosition) == null) {
      this.linePosition = parseInt(this.activatePosition);
    }
    if ((_ref1 = this.lastPosition) == null) {
      this.lastPosition = this.linePosition;
    }
    this.lineAnimation = new Task(function() {
      return _this.animateLine();
    });
    this.lineAnimation.interval = this.ANIMATION_FRAME_DURATION_MS;
    return this.lineAnimation.repeat();
  };

  GaussianCurve.prototype.animateLine = function() {
    if (this.animationFrame <= this.ANIMATION_FRAMES) {
      this.linePosition = (this.animationFrame / this.ANIMATION_FRAMES) * (this.activatePosition - this.lastPosition) + this.lastPosition;
    } else {
      this.lineAnimation.cancel();
      this.lastPosition = this.linePosition;
    }
    mgraphics.redraw();
    return this.animationFrame++;
  };

  return GaussianCurve;

})();
